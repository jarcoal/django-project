---
description: 
globs: *_tests.py
alwaysApply: false
---
# Always Use Factories in Tests

When writing tests, always use factory classes instead of direct model creation methods. This ensures consistency in test data and makes tests more maintainable.

## Do ✅

```python
# Good: Using factories
conversation = ConversationFactory()
message = MessageFactory(conversation=conversation)

# Good: Only specifying fields that are important to the test
message = MessageFactory(
    message_id="specific-id",  # Important for test logic
    is_outbound=False,  # Important for test logic
)

# Good: Setting related fields directly
message = MessageFactory(
    conversation__subject="test",  # Sets subject on the related conversation
    message_id="specific-id",
)
```

## Don't ❌

```python
# Bad: Using direct model creation
conversation = Conversation.objects.create(
    project=project,
    subject="Test Subject",
    created_at=timezone.now(),
)

# Bad: Over-specifying factory fields
message = MessageFactory(
    message_id="test123",
    from_address="test@example.com",
    to=["recipient@example.com"],
    subject="Test Subject",
    body_plain="Test body",
    body_html="<p>Test body</p>",
    is_outbound=False,
    created_at=timezone.now(),
)

# Bad: Creating related objects separately
conversation = ConversationFactory(subject="test")
message = MessageFactory(conversation=conversation)
```

## Guidelines

1. Always use factories instead of `Model.objects.create()`
2. Only specify fields in the factory call that are directly relevant to the test logic
3. Let the factory handle generating default values for other fields
4. If a field's value is important for the test's assertions or logic, then specify it in the factory call
5. Use factory traits or factory_boy's `SubFactory` for handling relationships between models
6. Use double-underscore notation to set fields on related objects directly
